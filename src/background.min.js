(() => {
  // src/background.js
  var DEFAULT_TARGET_LANGUAGE = "en";
  var API_CACHE_DURATION = 24 * 60 * 60 * 1e3;
  var translationCache = {};
  chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
    if (request.message === "translate") {
      const cacheKey = `${request.text}-${request.targetLang || DEFAULT_TARGET_LANGUAGE}`;
      if (translationCache[cacheKey] && Date.now() - translationCache[cacheKey].timestamp < API_CACHE_DURATION) {
        sendResponse({ translation: translationCache[cacheKey].translation });
        return true;
      }
      const text = encodeURIComponent(request.text);
      const targetLang = request.targetLang || DEFAULT_TARGET_LANGUAGE;
      const apiKey = "google_key-temple";
      const url = `https://translation.googleapis.com/language/translate/v2?key=${apiKey}&q=${text}&target=${targetLang}`;
      fetch(url).then((response) => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      }).then((data) => {
        if (data.data && data.data.translations && data.data.translations.length > 0) {
          const translation = data.data.translations[0].translatedText;
          translationCache[cacheKey] = {
            translation,
            timestamp: Date.now()
          };
          sendResponse({ translation });
        } else {
          throw new Error("Invalid API response format");
        }
      }).catch((error) => {
        console.error("Error translating:", error);
        sendResponse({
          translation: "Translation failed.",
          error: error.message
        });
      });
      return true;
    } else if (request.message === "saveWord") {
      saveWord(request.word);
      return true;
    } else if (request.message === "getWords") {
      getWords(function(words) {
        sendResponse({ words });
      });
      return true;
    } else if (request.message === "deleteWord") {
      deleteWord(request.wordId);
      return true;
    } else if (request.message === "updateWord") {
      updateWord(request.word);
      return true;
    } else if (request.message === "exportDictionary") {
      exportDictionary(function(data) {
        sendResponse({ data });
      });
      return true;
    } else if (request.message === "importDictionary") {
      importDictionary(request.data, request.mergeOption);
      return true;
    }
  });
  chrome.runtime.onInstalled.addListener(function() {
    chrome.contextMenus.create({
      id: "translateSelection",
      title: "Translate Selection",
      contexts: ["selection"]
    });
  });
  chrome.contextMenus.onClicked.addListener(function(info, tab) {
    if (info.menuItemId === "translateSelection") {
      chrome.tabs.sendMessage(tab.id, {
        message: "contextMenuTranslate",
        text: info.selectionText
      });
    }
  });
  function saveWord(word) {
    chrome.storage.local.get({ words: [] }, function(data) {
      const words = data.words;
      const existingIndex = words.findIndex(
        (w) => w.original === word.original && w.targetLanguage === word.targetLanguage
      );
      if (existingIndex >= 0) {
        words[existingIndex] = {
          ...words[existingIndex],
          ...word,
          timestamp: Date.now()
          // Update timestamp
        };
      } else {
        word.id = Date.now().toString();
        words.push(word);
      }
      chrome.storage.local.set({ words });
    });
  }
  function getWords(callback) {
    chrome.storage.local.get({ words: [] }, function(data) {
      callback(data.words);
    });
  }
  function deleteWord(wordId) {
    chrome.storage.local.get({ words: [] }, function(data) {
      let words = data.words;
      words = words.filter((word) => word.id !== wordId);
      chrome.storage.local.set({ words });
    });
  }
  function updateWord(updatedWord) {
    chrome.storage.local.get({ words: [] }, function(data) {
      let words = data.words;
      const index = words.findIndex((word) => word.id === updatedWord.id);
      if (index >= 0) {
        words[index] = updatedWord;
        chrome.storage.local.set({ words });
      }
    });
  }
  function exportDictionary(callback) {
    chrome.storage.local.get({ words: [] }, function(data) {
      const exportData = {
        words: data.words,
        exportDate: Date.now(),
        version: "1.0"
      };
      callback(JSON.stringify(exportData));
    });
  }
  function importDictionary(jsonData, mergeOption = "append") {
    try {
      const importedData = JSON.parse(jsonData);
      if (!importedData.words || !Array.isArray(importedData.words)) {
        throw new Error("Invalid import format");
      }
      chrome.storage.local.get({ words: [] }, function(data) {
        let currentWords = data.words;
        const importedWords = importedData.words;
        switch (mergeOption) {
          case "replace":
            currentWords = importedWords;
            break;
          case "merge":
            const wordMap = /* @__PURE__ */ new Map();
            currentWords.forEach((word) => {
              wordMap.set(word.id, word);
            });
            importedWords.forEach((word) => {
              wordMap.set(word.id, word);
            });
            currentWords = Array.from(wordMap.values());
            break;
          case "append":
          default:
            currentWords = currentWords.concat(importedWords);
            break;
        }
        chrome.storage.local.set({ words: currentWords });
      });
    } catch (error) {
      console.error("Error importing dictionary:", error);
    }
  }
  function cleanupCache() {
    const now = Date.now();
    for (const key in translationCache) {
      if (now - translationCache[key].timestamp > API_CACHE_DURATION) {
        delete translationCache[key];
      }
    }
  }
  setInterval(cleanupCache, 60 * 60 * 1e3);
})();
